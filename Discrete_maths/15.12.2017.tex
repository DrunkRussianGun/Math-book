\section{Алгоритмы нахождения остова минимального веса}
	Пусть дан граф $G = (V, E)$ и весовая функция $\alpha \colon E \to R^+$. Строим остов наименьшего веса $T = (V, P)$.
\subsection{Алгоритм Краскала}
\begin{enumerate}
	\item Выбираем ребро $e \in E$ с наименьшим весом: $T_1 = (V, \{ e \}) = (V, P_1)$.
	\item Выбираем ребро $e \in E$ с наименьшим весом такое, что $e \notin P_i$ и добавление этого ребра не приводит к образованию цикла в $T$. $T _{i+1} = (V, P_i \cup \{ e \})$.
	\item Повторяем шаг 2 $(|V| - 2)$ раз.
\end{enumerate}
\begin{proof}
	Пусть $T = (V, P)$~--- построенный остов, где $P = \{ e_1, e_2, \ldots, e_{n-1} \}$, $e_1, e_2, \ldots, e_{n-1}$~--- рёбра в порядке их добавления в остов, а также $D = (V, M)$~--- другой остов, где $M = \{ e_1', e_2', \ldots, e_{n-1}' \}$, $e_1', e_2', \ldots, e_{n-1}'$~--- рёбра в порядке неубывания их весов.
	
	Если $T \neq D$, то пусть $i$~--- наименьшее число такое, что $e_i \neq e_i'$. Рассмотрим $D' = (V, M \cup \{ e_i \})$. В этом графе ровно один цикл, причём $e_i$ входит в цикл.
	
	Данный цикл содержит ребро $e' \notin \{ e_1, \ldots, e_i \} \colon \alpha(e_i) \leqslant \alpha(e_i')$, т.\,к. $e_1, \ldots, e_i$ не образуют цикл. Если $\alpha(e') < \alpha(e_i)$, то на $i$-м шаге алгоритм выбрал бы $e'$ вместо $e_i$, т.\,к. $e_1, \ldots, e_{i-1}, e'$ не образуют цикл, потому что иначе $D$ содержал бы цикл.
	
	Пусть $D_1 = (V, M \cup \{ e_i\} \setminus \{ e_i' \})$. Этот граф~--- остов, причём $\alpha(D_1) \leqslant \alpha(D)$ и у $T$ и $D_1$ на 1 общее ребро больше, чем у $T$ и $D$. Повторяя, получим $D_k = T$. Значит, вес построенного остова не превосходит веса любого другого остова.
\end{proof}

\subsection{Алгоритм Прима}
	Строится последовательность деревьев $S_1 \subset S_2 \subset \ldots \subset S_n$.
\begin{enumerate}
	\item Выбираем произвольную вершину $v$. $S_1 = (\{ v \}, \varnothing)$.
	\item Пусть $S_i = (V_i, E_i)$. Находим ребро $eэ \in E$ наименьшего веса, инцидентное одной из вершин $v_i$, добавление которого не приводит к образованию цикла.
	
	$e' = (u, v)$, где $u \in V_i$, $v \notin V_i$. $S_{i+1} = {V_i \cup \{ v \}, E_i \cup \{ e' \}}$.
	\item Повторяем шаг 2 $(n - 1)$ раз. $S_n$~--- искомый остов.
\end{enumerate}

\section{Помеченные деревья}
\begin{definition}
	Дерево с $n$ вершинами, которым сопоставлены числа $1, \ldots, n$, называется \textbf{помеченным}.
\end{definition}

\subsection{Код Прюфера}
	Каждому помеченному дереву можно взаимнооднозначно сопоставить последовательность из $(n - 2)$ чисел от $1$ до $n$, называемая \textbf{кодом Прюфера}. Алгоритм построения кода Прюфера для помеченного дерева $G = (V, E)$:
\begin{enumerate}
	\item Выбираем висячую вершину $v$ с наименьшим номером.
	\item Добавляем номер вершины, смежной с $v$, в код.
	\item Удаляем $v$ и ребро, инцидентное $v$, из дерева.
	\item Повторить, начиная с шага 1, $(n - 2)$ раза.
\end{enumerate}

\begin{statement}
	Различным помеченным деревьям соответствуют различные коды Прюфера.
\end{statement}
\begin{proofmathind}
	\indbase При $n = 3$ легко проверить.
	\indstep Пусть утверждение верно при $n \geqslant 3$, $G = (V, E)$ и $G' = (V', E')$~--- различные помеченные деревья с $(n + 1)$ вершинами в каждом.
	\begin{enumerate}
		\item Пусть в $G$ и $G'$ вершины с наименьшим номером смежны с вершинами с различными номерами.
		\item Пусть в $G$ и $G'$ вершины с наименьшим номером смежны с вершинами с одинаковыми номерами. Выполняем шаг построения кода, тогда оставшиеся деревья различны, значит, по предположению индукции у них различные коды.
	\end{enumerate}
	\indend
\end{proofmathind}

	Алгоритм построения дерева по коду $A_0 = (a_1, \ldots, a_{n-2})$.
\begin{enumerate}
	\item Пусть $B_0 = (1, \ldots, n)$.
	\item Находим наименьшее $b \in B_i \colon b \notin A_i$. Тогда в дереве есть ребро $\{ b, a_i \}$. $A_{i+1} = A_i \setminus \{ a_i \}$, $B_{i+1} = B_i \setminus \{ b \}$.
	\item Повторяем шаг 2 $(n - 2)$ раз. Получим $B_{n-2} = \{ b', b'' \}$, значит, в дереве есть ребро $\{ b', b'' \}$.
\end{enumerate}

\begin{statement}
	Указанный алгоритм построения дерева по коду из $n$ чисел строит дерево.
\end{statement}
\begin{proofmathind}
	\indbase При $n = 1$ легко проверить.
	\indstep Рассмотрим графы $T_1, \ldots, T_{n-1}$, полученные в процессе построения дерева. $T_1$ не содежрит циклов. $T_2$ получается из $T_1$ либо добавлением новой вершины, либо добавлением моста, что не приводит к появлению цикла.
	
	$T_{n-1}$ не содержит циклов и содержит $n$ вершин и $(n - 1)$ ребёр, значит, $T_{n-1}$~--- дерево.
	\indend
\end{proofmathind}

\begin{theorem}[Кэли]
	Пусть $G = (V, E)$~--- дерево, $n = |V|$, вершинам $G$ сопоставлены числа $1, \ldots, n$. Всего можно составить $n^{n-2}$ таких неизоморфных деревьев.
\end{theorem}